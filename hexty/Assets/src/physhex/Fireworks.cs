// Copyright (c) 2020 Rafael Alcaraz Mercado. All rights reserved.
// Licensed under the MIT license <LICENSE-MIT or http://opensource.org/licenses/MIT>.
// All files in the project carrying such notice may not be copied, modified, or distributed
// except according to those terms.
// THE SOURCE CODE IS AVAILABLE UNDER THE ABOVE CHOSEN LICENSE "AS IS", WITH NO WARRANTIES.

using System.Collections.Generic;
using UnityEngine;

namespace PhysHex
{

/// <summary>
/// Properties of a firework spark.
/// </summary>
[System.Serializable]
public class FireworkSpark
{
    /// <summary>
    /// Projectile intrinsic of the spark.
    /// </summary>
    public Projectile Projectile;

    /// <summary>
    /// The payload index this spark will fuse when the projectile expires.
    /// </summary>
    public int CurrentPayload;
}

/// <summary>
/// Simple class that wraps a firework payload.
/// A fused payload will generate a list of sparks
/// that know their own payload to fuse, randomly generated
/// constrainted by the properties of this class.
/// </summary>
[System.Serializable]
public class FireworkPayload
{
    /// <summary>
    /// Minimum expiry value allowed for spawned sparks when fused.
    /// </summary>
    public float MinExpiry;

    /// <summary>
    /// Maximum expiry value allowed for spawned sparks when fused.
    /// </summary>
    public float MaxExpiry;

    /// <summary>
    /// Minimum velocity value allowed for spawned sparks' random velocity when fused.
    /// </summary>
    public Vector3 MinVelocity;

    /// <summary>
    /// Maximum velocity value allowed for spawned sparks' random velocity when fused.
    /// </summary>
    public Vector3 MaxVelocity;

    /// <summary>
    /// Damping value of spawned sparks when fused.
    /// </summary>
    public float Damping;

    /// <summary>
    /// Number of sparks that will be generated with random expiry and velocities when fused.
    /// </summary>
    public int FuseCount;

    /// <summary>
    /// Determines if after generating a random velocity on a spawned spark constrainted by min/max properties
    /// the velocity will be increased by the spark parent's velocity when fused.
    /// This allows to simulate a "speed up" effect on each fuse.
    /// </summary>
    public bool AggregateParentVelocity;

    /// <summary>
    /// Determines if after generating a random velocity on a spawned spark constrainted by min/max properties
    /// the velocity will be transformed into a vector that points in the same direction the spark parent's velocity when fused.
    /// This allows to simulate a sort of tree effect, where each spark tries to follow the same direction overall.
    /// </summary>
    public bool UseParentDirection;

    /// <summary>
    /// Computes a random expiry value based on the constraints.
    /// </summary>
    public float RandomExpiry { get => Random.Range(MinExpiry, MaxExpiry); }

    /// <summary>
    /// Computes a random velocity value based on the constraints.
    /// </summary>
    public Vector3 RandomVelocity { get => new Vector3(Random.Range(MinVelocity.x, MaxVelocity.x), Random.Range(MinVelocity.y, MaxVelocity.y), Random.Range(MinVelocity.z, MaxVelocity.z)); }

    /// <summary>
    /// Fuses this payload and spawns sparks with random values based on the constraints.
    /// The parent spark's particle determines the initial position for all children.
    /// </summary>
    /// <param name="parent">Specifies who the parent spark's particle is.</param>
    /// <param name="payload">Supplies the payload the new spawned sparks carry.</param>
    /// <returns></returns>
    public List<FireworkSpark> Fuse(Particle parent, int payload)
    {
        var sparks = new List<FireworkSpark>();
        for (int i = 0; i < FuseCount; ++i)
        {
            var particle = parent.Clone();
            particle.Velocity = RandomVelocity;
            particle.Velocity += AggregateParentVelocity ? parent.Velocity : Vector3.zero;
            particle.Velocity = UseParentDirection ? parent.Velocity.normalized * particle.Velocity.magnitude : particle.Velocity;
            particle.Damping = Damping;
            var spark = new FireworkSpark {
                Projectile = new Projectile(RandomExpiry, particle.Velocity.normalized, particle),
                CurrentPayload = payload
            };
            spark.Projectile.Particle.Damping = Damping;
            sparks.Add(spark);
        }
        return sparks;
    }
}

/// <summary>
/// Firework class that manages the lifetime of sparks generated by fusing firework payload.
/// A user specified projectile determines the initial behavior of the firework; think of this
/// as the initial firework carrying the entire payload.
/// An initial projectile that has already expired will automatically fuse the first time the
/// firework instance is integrated in the simulation.
/// </summary>
[System.Serializable]
public class Firework
{
    /// <summary>
    /// List of sparks actively tracked by the firework.
    /// </summary>
    public List<FireworkSpark> Sparks = new List<FireworkSpark>();

    /// <summary>
    /// List of valid payloads in the firework.
    /// The current payload property of a spark determines where in the payload
    /// chain it currently sits at.
    /// </summary>
    public readonly List<FireworkPayload> Payloads;

    /// <summary>
    /// Constructor that expects at least one payload and an initial projectile.
    /// </summary>
    /// <param name="payloads">List of fusable payloads. Must be at least one.</param>
    /// <param name="projectile">Initial projectile, fusing it will trigger thte first payload.</param>
    public Firework(List<FireworkPayload> payloads, Projectile projectile)
    {
        if (payloads.Count < 1)
        {
            throw new System.ArgumentException("Firework payload must have at least one entry");
        }

        Payloads = payloads;
        Sparks = new List<FireworkSpark>() { new FireworkSpark { Projectile = projectile, CurrentPayload = 0 } };
    }

    /// <summary>
    /// Integrate the firework by integrating the underlying sparks' projectiles.
    /// This function returns true if at least one spark integrated (not expired) or fused
    /// (expired and there was still payload).
    /// </summary>
    /// <param name="duration">Supplies the duration of time units that have occured since the last time.</param>
    /// <returns>True if the projectile hasn't expired after the increase in duration.</returns>
    public bool Integrate(float duration)
    {
        if (Sparks == null) return false;
        var expiredIndexes = new List<int>();
        int index = -1;
        bool anyIntegrated = false;
        foreach (var s in Sparks)
        {
            ++index;
            if (!s.Projectile.Integrate(duration))
            {
                expiredIndexes.Add(index);
            }
            else
            {
                anyIntegrated = true;
            }
        }
        bool anyFused = false;
        foreach (var i in expiredIndexes)
        {
            anyFused |= StepPayload(i);
        }
        return anyIntegrated || anyFused;
    }

    private bool StepPayload(int index)
    {
        var spark = Sparks[index];
        if (index < Sparks.Count && spark.CurrentPayload < Payloads.Count)
        {
            Sparks.AddRange(Payloads[spark.CurrentPayload].Fuse(spark.Projectile.Particle, spark.CurrentPayload + 1));
            Sparks.RemoveAt(index);
            return true;
        }
        return false;
    }
}

}